name: Infrastructure as Code CI/CD

on:
  push:
    branches: [main, develop]
    paths:
      - 'environments/**'
      - 'modules/**'
      - '.github/workflows/infrastructure.yml'
  pull_request:
    branches: [main]
    paths:
      - 'environments/**'
      - 'modules/**'

  # Allow manual workflow dispatch
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - production
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TF_VERSION: 1.6.0
  TERRAGRUNT_VERSION: 0.53.0
  AWS_REGION: us-west-2

permissions:
  contents: read
  security-events: write
  id-token: write
  pull-requests: write
  actions: read

jobs:
  # Security and validation checks
  security-checks:
    name: Security and Validation
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: |
          echo "Checking Terraform file formatting..."
          # Check format for all .tf files
          terraform fmt -check -recursive || {
            echo "‚ùå Terraform files are not properly formatted."
            echo "Run 'terraform fmt -recursive' to fix formatting issues."
            exit 1
          }
          echo "‚úÖ All Terraform files are properly formatted."

      - name: Terraform Validation
        run: |
          # Skip validation for directories without complete Terraform configurations
          echo "Validating Terraform configurations..."
          
          # Only validate environments that have main.tf files
          for env_dir in environments/*/; do
            if [[ -f "$env_dir/main.tf" ]]; then
              echo "Validating environment: $env_dir"
              cd "$env_dir"
              terraform init -backend=false -input=false
              terraform validate
              cd - > /dev/null
            else
              echo "Skipping $env_dir - no main.tf found"
            fi
          done
          
          # Validate modules that have complete configurations
          for module_dir in modules/*/*/; do
            if [[ -f "$module_dir/main.tf" ]]; then
              echo "Validating module: $module_dir"
              cd "$module_dir"
              terraform init -backend=false -input=false
              terraform validate
              cd - > /dev/null
            else
              echo "Skipping $module_dir - no main.tf found"
            fi
          done

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: latest

      - name: Run TFLint
        run: tflint --recursive

      - name: Create reports directory
        run: mkdir -p reports

      - name: Run Checkov (Security Scan)
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: terraform
          output_format: sarif
          output_file_path: reports/checkov.sarif
        continue-on-error: true

      - name: Upload Checkov SARIF file
        uses: github/codeql-action/upload-sarif@v3
        if: always() && hashFiles('reports/checkov.sarif') != ''
        with:
          sarif_file: reports/checkov.sarif

      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: .

  # Determine which environments to deploy
  determine-environments:
    name: Determine Environments
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.determine.outputs.environments }}
      matrix: ${{ steps.determine.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environments to deploy
        id: determine
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual dispatch - use specified environment
            echo "environments=[\"${{ github.event.inputs.environment }}\"]" >> $GITHUB_OUTPUT
            echo "matrix={\"environment\":[\"${{ github.event.inputs.environment }}\"]}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Main branch - deploy to staging and production (with approval)
            echo "environments=[\"staging\"]" >> $GITHUB_OUTPUT
            echo "matrix={\"environment\":[\"staging\"]}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            # Develop branch - deploy to dev
            echo "environments=[\"dev\"]" >> $GITHUB_OUTPUT
            echo "matrix={\"environment\":[\"dev\"]}" >> $GITHUB_OUTPUT
          else
            # PR or other branches - only plan for dev
            echo "environments=[\"dev\"]" >> $GITHUB_OUTPUT
            echo "matrix={\"environment\":[\"dev\"]}" >> $GITHUB_OUTPUT
          fi

  # Plan infrastructure changes
  terraform-plan:
    name: Terraform Plan (${{ matrix.environment }})
    runs-on: ubuntu-latest
    needs: [security-checks, determine-environments]
    strategy:
      matrix: ${{ fromJson(needs.determine-environments.outputs.matrix) }}
    env:
      ENVIRONMENT: ${{ matrix.environment }}
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-terraform
          role-session-name: terraform-${{ matrix.environment }}-${{ github.run_number }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          cd environments/${{ matrix.environment }}
          terraform init

      - name: Terraform Plan
        run: |
          cd environments/${{ matrix.environment }}
          terraform plan -out=tfplan-${{ matrix.environment }}-${{ github.run_number }}

      - name: Upload plan artifact
        uses: actions/upload-artifact@v3
        with:
          name: tfplan-${{ matrix.environment }}-${{ github.run_number }}
          path: environments/${{ matrix.environment }}/tfplan-${{ matrix.environment }}-${{ github.run_number }}
          retention-days: 30

      - name: Comment PR with plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { exec } = require('child_process');
            
            exec(`cd environments/${{ matrix.environment }} && terraform show -no-color tfplan-${{ matrix.environment }}-${{ github.run_number }}`, (error, stdout) => {
              if (error) {
                console.error(error);
                return;
              }
              
              const output = stdout.slice(0, 60000); // Limit output size
              const comment = `## Terraform Plan for ${{ matrix.environment }}
              
              \`\`\`terraform
              ${output}
              \`\`\`
              
              ${output.length >= 60000 ? '\n**Note: Output truncated due to length limits.**' : ''}`;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            });

  # Apply infrastructure changes (with environment-specific approvals)
  terraform-apply:
    name: Terraform Apply (${{ matrix.environment }})
    runs-on: ubuntu-latest
    needs: [terraform-plan, determine-environments]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.ref == 'refs/heads/develop' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
    strategy:
      matrix: ${{ fromJson(needs.determine-environments.outputs.matrix) }}
    environment: 
      name: ${{ matrix.environment }}
      url: ${{ steps.apply.outputs.cluster_endpoint }}
    env:
      ENVIRONMENT: ${{ matrix.environment }}
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-terraform
          role-session-name: terraform-apply-${{ matrix.environment }}-${{ github.run_number }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Download plan artifact
        uses: actions/download-artifact@v3
        with:
          name: tfplan-${{ matrix.environment }}-${{ github.run_number }}
          path: environments/${{ matrix.environment }}/

      - name: Terraform Init
        run: |
          cd environments/${{ matrix.environment }}
          terraform init

      - name: Terraform Apply
        id: apply
        run: |
          cd environments/${{ matrix.environment }}
          terraform apply -auto-approve tfplan-${{ matrix.environment }}-${{ github.run_number }}
          
          # Capture outputs for environment URL
          CLUSTER_ENDPOINT=$(terraform output -raw cluster_endpoint || echo "")
          echo "cluster_endpoint=$CLUSTER_ENDPOINT" >> $GITHUB_OUTPUT

      - name: Post-deployment validation
        run: |
          cd environments/${{ matrix.environment }}
          # Validate EKS cluster is accessible
          if aws eks describe-cluster --name $(terraform output -raw cluster_name) --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "‚úÖ EKS cluster is accessible"
          else
            echo "‚ùå EKS cluster validation failed"
            exit 1
          fi

  # Destroy infrastructure (manual only, with extra protection)
  terraform-destroy:
    name: Terraform Destroy (${{ github.event.inputs.environment }})
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy'
    environment: 
      name: destroy-${{ github.event.inputs.environment }}
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Confirm destruction
        run: |
          echo "üö® DESTRUCTIVE ACTION: About to destroy ${{ github.event.inputs.environment }} environment"
          echo "This action is irreversible and will remove all infrastructure resources."

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-terraform
          role-session-name: terraform-destroy-${{ github.event.inputs.environment }}-${{ github.run_number }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        run: |
          cd environments/${{ github.event.inputs.environment }}
          terraform init

      - name: Terraform Destroy
        run: |
          cd environments/${{ github.event.inputs.environment }}
          terraform destroy -auto-approve

  # Cost estimation (runs on PRs)
  cost-estimation:
    name: Cost Estimation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [terraform-plan]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Infracost
        uses: infracost/actions/setup@v2
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}

      - name: Generate cost estimate
        run: |
          # This is a placeholder - actual implementation would require Infracost setup
          echo "üí∞ Cost estimation would be performed here with Infracost"
          echo "Estimated monthly cost changes would be posted to PR"

  # Notification on completion
  notify:
    name: Notify Completion
    runs-on: ubuntu-latest
    needs: [terraform-apply, determine-environments]
    if: always() && (needs.terraform-apply.result == 'success' || needs.terraform-apply.result == 'failure')
    steps:
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          text: |
            Infrastructure deployment completed
            Environment: ${{ join(fromJson(needs.determine-environments.outputs.environments), ', ') }}
            Status: ${{ needs.terraform-apply.result }}
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
